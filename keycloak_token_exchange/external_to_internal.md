# Demonstrating external to internal token exchange

If you have done the instructions in the [README](./README.md), you have demonstrated internal-internal token exchange using authentication via SPIRE-issued JWTs. 

It is sometimes the case that we wish to exchange using a token from an external identity provider to an internal token. This document will demonstrate how to do this with an external Keycloak realm. 

## Tutorial Prerequisites

Have a Keycloak instance running with preview features and log in. This tutorial will assume you are running on `localhost:8080`, but this can be adjusted. 

## External to Internal Token Exchange between Keycloak Realms

We will create two realms with a single user each. Both user accounts will represent the same user. These users will be linked and we will simulate obtaining an access token for a client app in Realm A, then exchanging the access token for one of Realm B

### Step 1: Create Realm A

Below, you will create a realm, a user, and two client applications. One is for the other realm to use to authenticate to and interact with RealmA, and the other is an example client application

1. In the Keycloak UI, click "Create Realm" at the top
2. Name it `RealmA`. 
3. Create a user with username `user-a`. When it is created, note the `ID` of the user in the first field. This is NOT the username. 
4. Click on `Credentials` at the top of the screen and set some password. Keep a note on this password
5. Go to `Clients` in the sidebar and `Create client`
6. Enter client ID `demo-app-a`. 
7. Set `Client authentication` to On. 
8. Click `Save`
9. In the breadcrumbs at the top, go to `Credentials`. You should see a secret. Save this secret for a later step. 
9. Go to `Clients` in the sidebar and `Create client`
10. Enter client ID `realm-b-client`. 
11. Set `Client authentication` to On. 
12. Click `Save`
12. In the breadcrumbs at the top, go to `Credentials`. You should see a secret. Save this secret for a later step. 

At the end of this set of instructions you should have stored:
- User's ID (separate from username) and password
- Client `demo-app-a` secret
- Client `realm-b-client` secret

### Step 2: Create Realm B

1. At the top, click "Create Realm" again. 
2. Repeat steps from previous section, except rename accordingly: 
- Realm Name: `RealmB`
- User Name: `user-b`
- Application Client ID: `demo-app-b`
- Realm Client ID: `realm-a-client`

Again, keep note of the `Client Secrets` generated by Keycloak for both clients. 

At the end of this set of instructions you should have stored:
- User's ID (separate from username) and password
- Client `demo-app-b` secret
- Client `realm-a-client` secret

### Step 3: Link Realm A and Realm B

A requirement for exchanging user tokens across IdPs is that the user account is linked. Typically, this is done via multiple UI redirects, but we can do this in the Keycloak UI as well. 

First let's add the link to `RealmB`. 

1. In the sidebar, under `Configure > Identity providers`, and click on `Keycloak OpenID Connect`. If you were connecting another IdP, you would select a different one. 
2. Enter the alias as `keycloak-realm-a`
3. Enter the Discovery Endpoint: `http://localhost:8080/realms/RealmA/.well-known/openid-configuration`
4. Enter the Client ID `realm-b-client`
5. Enter the client secret you noted when created the Client `realm-b-client` in RealmA. 
6. Click `Add`. 

Now we will add the link to `RealmA`. 

1. Select `RealmA` from the top dropdown. 
2. Perform the steps just above except renaming accordingly:
- Alias: `keycloak-realm-b`
- Discovery Endpoint: `http://localhost:8080/realms/RealmB/.well-known/openid-configuration`
- Client ID: `realm-a-client`
- Client Secret: the secret you noted when creating the `realm-a-client` in RealmB

### Step 4: Link the user accounts

Now lets add the identity provider links. First let's set up RealmA's link:

1. Select `Users` in the sidebar and select the user you have created. 
2. In the breadcrumbs at the top, select `Identity provider links`
3. You should see an option to `Link account` to `Keycloak-realm-b`. Click on this. 
4. Enter the User ID you have obtained from the user in **Realm B**
5. Enter the username `user-b`
6. Now do the same for the user in Realm B, but with `user-a`'s id. 

### Step 5: Set the proper client scopes

Let's restrict the information contained in the access tokens we will obtain, and define a scope for the audience in `demo-app-a`. 

1. In `RealmB`, go to `Clients > demo-app-b > Client scopes > demo-app-b-dedicated > Scope`. 
2. Set `Full scope allowed` to Off. 
3. In `RealmA`, go to `Clients > demo-app-a > Client scopes > demo-app-a-dedicated > Scope`. 
4. Set `Full scope allowed` to Off. 
5. In the Sidebar, select `Client scopes`. Then click `Create Client scope`. 
6. Enter name `demo-app-a-aud` and set the type to optional. 
7. Under `Mappers` at the top, click `Configure a new mapper` and select `Audience`. 
8. Name this mapper `demo-app-a-client-aud`. Select `demo-app-a` under `Included Client Audience`. Click Save. 
9. Go to `Clients > demo-app-a > Client scopes > Add client scope`
10. Select `demo-app-a-aud` and Add as Default. 

The above allows the `demo-app-a` application to exchange the token with its own ID as the audience by default. If you wished to request for a different ID, you will need to configure the Client scopes accordingly. 

### Step 6: Grant permission for the exchange

We need to give access to the calling client that they may perform token exchange. 

1. Go to `RealmA` and click on `Identity providers` on the left sidebar. 
2. Click on `keycloak-realm-b`, then go to `Permissions` in the top
3. Enable `Permissions` and `token-exchange` appears below. Click on `token-exchange`. 
4. Here we can define policies for what clients are allowed to interact with external tokens. Click on `Policies` field and select `Create Client Policy`. 
5. Click on `Client`. 
6. Enter `demo-app-a-client` under the Policy Name, and select `demo-app-a` under clients. Click Save. 
7. Go back to `Identity providers > keycloak-realm-b > Permissions > token-exchange`. Then add the `demo-app-a-client` policy under Policies. Click `Save`. 

If the above set of instructions is not completed, the client application will not trust the received token. 

### Perform the flows

Now that we have performed the necessary Keycloak setup, we can work through the flows. This will consist of the following steps:

1. Log into RealmB and obtain an access token. This access token would be presented directly to the application in RealmA. 
2. Perform the token exchange by demo-app-a. 

First let's export all the relevant information in the terminal: 

```
export CLIENT_A_SECRET=<secret for demo-app-a in RealmA>
export USERB_PASSWORD=<password for user in RealmB>
export CLIENT_B_SECRET=<secret for demo-app-b in RealmB>
```

#### Log into Realm B and obtain a RealmB access token

Below we make a call to log in and obtain an initial Access token to RealmB using the `demo-app-b` client. 

```
export ACCESS_TOKEN=$(curl -sX POST -H "Content-Type: application/x-www-form-urlencoded" \
-d "grant_type=password" \
-d "username=user-b" \
-d "password=$USERB_PASSWORD" \
-d "client_id=demo-app-b" \
-d "client_secret=$CLIENT_B_SECRET" \
-d "scope=openid" \
"http://localhost:8080/realms/RealmB/protocol/openid-connect/token" | jq -r .access_token)
```

Some notes on the above command:
1. We are using the password grant, which assumes the application is directly given the username and password of the user. This is fine for demo, but generally **discouraged in production**. 
2. It is **required** that `scope` includes `openid` for external token exchanges. 

#### Perform external to internal token exchange

The access token above can be passed directly to the application `demo-app-a` that is registered with RealmA. When the application receives this access token, it can verify the external token by performing token exchange. 

```
curl -sX POST -H "Content-Type: application/x-www-form-urlencoded" \
    -d "client_id=demo-app-a" \
    -d "client_secret=$CLIENT_A_SECRET" \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "subject_token=$ACCESS_TOKEN" \
    -d "subject_issuer=keycloak-realm-b" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
        "http://localhost:8080/realms/RealmA/protocol/openid-connect/token" | jq -r
```

If the application wants an access token for a different audience, it must be configured to do so, and must specify using `-d "audience=<desired client id>" argument. 


## TODOs:
1. How to validate tokens using keycloak endpoint

```
curl -X POST "http://localhost:8080/realms/RealmA/protocol/openid-connect/token/introspect" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "client_id=demo-app-a" \                         
     -d "client_secret=$CLIENT_A_SECRET" \           
     -d "token=$ACCESS_TOKEN"      
```

This does not work for external tokens. It seems the token exchange must be done immediately, and this implicitly does some validation? 

2. How does the internal client application know the `subject_issuer`. Probably the IdP alias should be the name of the issuer that is found in the received access token. Hopefully this does not cause problems. 
